package main

// func main() {
// 	var s = []string{"1", "2", "3"}
// 	modifySlice(s)
// 	fmt.Println(s)
// }

func modifySlice(i []string) {
	i[0] = "3"
	i = append(i, "4")
	i[1] = "5"
	i = append(i, "6")
}

// Программа выведет: [3 2 3]

// Слайс - это структура (header), состоящая из трех полей:
// указатель на массив, длина (len) и емкость (cap). Когда слайс передается
// в функцию, Go копирует эту структуру, но указатель всё еще смотрит на тот же массив

// Пошаговое выполнение:
// i[0] = "3": Так как указатель в функции modifySlice и в main одинаковый,
// это изменение напрямую правит данные в памяти и оригинальный слайс в main теперь [3 2 3]
// i = append(i, "4"): Здесь происходит преаллокация. Начальная емкость слайса
// была 3, для добавления 4-го элемента Go вынужден выделить новый массив в памяти.
// После append локальная переменная i начинает указывать на новый, расширенный массив
// Оригинальная переменная s в main продолжает указывать на старый массив
// и сохраняет свою старую длину (3) и значение [3 2 3]
// i[1] = "5": Это изменение происходит уже в новом массиве, который "видит" только функция
// В main значение под индексом 1 остается прежним и более неменяется

// Итог: Функция main ничего не знает о переаллокации памяти внутри функции
// Она продолжает отображать первые 3 элемента исходного массива

// Как исправить: чтобы изменять длину слайса в функции нужно использовать append так,
// чтобы это увидел вызывающий код, надо:
// Либо возвращать новый слайс: s = modifySlice(s)
// Либо передавать указатель на слайс: func modifySlice(i *[]string)
// Без этого любые операции append, превышающие емкость (cap), станут "невидимыми"
// для внешнего кода
