package main

import (
	"os"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

// func main() {
// 	err := Foo()
// 	fmt.Println(err)
// 	fmt.Println(err == nil)
// }

// Программа выведет:
// <nil>
// false

// Объяснение внутреннего устройства интерфейсов
// В языке Go интерфейс под капотом - это структура из двух полей (указателей):
// Тип (Type): информация о том, какой тип данных записан в интерфейс
// Значение (Value): указатель на конкретные данные этого типа
// Интерфейс равен nil только тогда, когда оба поля (Тип и Значение) пусты (равны nil)

// Почему err == nil выдает false?
// В функции Foo происходит следующее:
// Вы создаете переменную err конкретного типа *os.PathError. Она равна nil
// Когда вы возвращаете её как интерфейс error, Go упаковывает её в интерфейсную структуру:
// Тип теперь равен *os.PathError, Значение равно nil
// Поскольку поле Тип заполнено, сам интерфейс уже не является абсолютно пустым
// Поэтому проверка на nil дает false

// Отличие интерфейсов от пустых интерфейсов
// Интерфейс (error, io.Reader и т.д.):
// Содержит набор методов
// В него можно положить только тот объект, который реализует эти методы
// Внутри называется iface
// Пустой интерфейс (interface{} или any):
// Не содержит методов
// В него можно положить любой тип данных
// Внутри называется eface
