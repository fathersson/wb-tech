// // Package main предоставляет функционал для получения точного времени через NTP.
package main

// import (
// 	"fmt"
// 	"os"
// 	"time"

// 	"github.com/beevik/ntp"
// )

// // getNTPTime запрашивает текущее время с внешнего сервера времени.
// func getNTPTime() (time.Time, error) {
// 	// Рекомендуется добавлять таймаут для сетевых запросов
// 	t, err := ntp.Time("pool.ntp.org")
// 	if err != nil {
// 		return time.Time{}, err
// 	}
// 	return t, nil
// }

// func main() {
// 	t, err := getNTPTime()
// 	if err != nil {
// 		// Вывод в STDERR (дескриптор 2)
// 		fmt.Fprintf(os.Stderr, "ошибка при получении NTP времени: %v\n", err)
// 		// Завершение с кодом 1
// 		os.Exit(1)
// 	}

// 	// Вывод в STDOUT (дескриптор 1)
// 	fmt.Printf("Точное время (NTP): %s\n", t.Format(time.RFC3339))
// }

// STDERR (Standard Error) — это стандартный поток вывода,
// зарезервированный специально для сообщений об ошибках и
// диагностической информации
// -----------------------------------------------------------------
// 1. Существует стандартных потока
// Когда вы запускаете любую программу операционная система
// автоматически открывает для неё три канала:
// STDIN (0): Стандартный ввод (данные от клавиатуры)
// STDOUT (1): Стандартный вывод (основной результат работы программы)
// STDERR (2): Стандартная ошибка (текст ошибок, логи, предупреждения)
// -----------------------------------------------------------------
// 2. Зачем разделять STDOUT и STDERR?
// Главная цель - отделить полезные данные от служебного шума
// Представьте, что ваша программа на Go запрашивает время по NTP
// и выдает его в консоль. Если в процессе возникнет сетевая ошибка,
// и вы запишете её в тот же поток, что и время, другие программы,
// которые читают вывод вашего сервиса, «сломаются», так как вместо
// даты получат текст ошибки.
// -----------------------------------------------------------------
// 3. Почему это важно?
// Логирование: Контейнеры Docker автоматически собирают всё,
// что летит в STDERR, и помечают это как логи уровня Error или Warning
// Конвейеры (Pipes): Если вы передаете результат работы одной программы
// в другую через «пайп» (program1 | program2), program2 получит только
// данные из STDOUT. Если program1 упадет, текст ошибки не попадет во вторую
// программу, а останется в STDERR, что предотвратит цепочку неверных действий

// Код должен проходить проверки (vet и golint),
// т.е. быть написан идиоматически корректно.
// -----------------------------------------------------------------
// 1. Что такое go vet? - Официальный стандартный анализатор
// Что ищет: Логические ошибки, которые пропускает компилятор
// неверные форматы в Printf, забытые переменные, подозрительный код
// -----------------------------------------------------------------
// 2. Что такое golint? - Анализатор стиля (линтер)
// Что ищет: Нарушения стандартов оформления: отсутствие комментариев
// к функциям, плохие имена переменных (например, ntp_time вместо ntpTime),
// избыточный код.
// Цель: Гарантировать читаемость и единообразие кода
// -----------------------------------------------------------------
// 3. Что значит «идиоматически корректно»?
// Ошибки: Возвращаются как значения, а не через исключения
// Имена: Краткие, понятные, в camelCase
// Документация: Каждая функция имеет описание
// Простота: Отсутствие лишних усложнений (например, не использовать any там,
// где можно указать конкретный тип)
// -----------------------------------------------------------------
// Краткая формула для понимания:
// «Код должен быть не просто рабочим, а чистым, документированным
// и написанным по правилам сообщества Go, чтобы любой другой разработчик
// мгновенно в нём разобрался».
