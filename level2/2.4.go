package main

// func main() {
// 	ch := make(chan int)
// 	go func() {
// 		for i := 0; i < 10; i++ {
// 			ch <- i
// 		}
// 		// close(ch) // Канал закрыт, приемник выйдет из цикла без ошибки
// 	}()
// 	for n := range ch {
// 		println(n)
// 	}
// }

// Что выведет программа?
// Числа от 0 до 9 включительно
// fatal error: all goroutines are asleep - deadlock!

// Объяснение вывода:
// Анонимная горутина записывает 10 чисел в небуферизированный канал ch
// Основной цикл for range в функции main успешно их считывает и выводит в консоль
// Цикл for n := range ch бесконечно читает из канала, он останавливается только
// в одном случае, если канал будет явно закрыт функцией close()

// Причина Deadlock:
// Когда анонимная горутина завершает свой цикл, она прекращает работу
// но канал ch остается открытым и сновная горутина (main) продолжает ждать новых данных
// на строке for n := range ch, т.к отправителей больше нет, а получатель (main) заблокирован
// планировщик Go диагностирует состояние Deadlock и завершает программу с ошибкой

// Как исправить код:
// Чтобы избежать ошибки, необходимо вызвать close(ch) на стороне отправителя
// после завершения цикла. Это пошлет сигнал получателю, что данных больше не будет,
// и цикл range корректно завершится
