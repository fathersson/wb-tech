// Негативные последствия
// Поскольку justString является глобальной переменной,
// она будет существовать все время работы программы
// Пока жива justString, сборщик мусора не может освободить память,
// занятую исходной огромной строкой v
// Итог: даже если вам нужны всего 100 байт,
// в оперативной памяти будет удерживаться весь объем данных,
// созданный функцией createHugeString
// в данном примере это может быть не критично для 1 << 10,
// но при масштабировании программы может закончиться память

// Что происходит с переменной justString?
// justString становится срезом большой строки v
// В Go строки - это структуры, которые содержат указатель
// на базовый массив байт в памяти
// Когда вы выполняете justString = v[:100],
// новая строка justString не копирует первые 100 символов в новую область памяти
// Вместо этого она просто получает указатель на тот же самый огромный массив
// байт, в котором хранится v, но с ограниченной длиной в 100 символов

// Решение
// Чтобы избежать утечки памяти, необходимо принудительно скопировать
// нужную часть строки в новую область памяти. Это позволит
// сборщику мусора удалить исходный массив
// после завершения работы функции someFunc

package main

// import "strings"

// var justString string

// func someFunc() {
// 	v := createHugeString(1 << 10)
// 	// Это создает новую независимую копию подстроки.
// 	justString = strings.Clone(v[:100])
// }

// func main() {
// 	someFunc()
// }
