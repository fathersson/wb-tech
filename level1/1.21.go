package main

import "fmt"

// --- 1. Существующая инфраструктура ---
// jsonDocument - это наш тип данных, который мы имеем в приложении
// Его интерфейс несовместим с сервисом аналитики
// convertToXml - метод, который превращает JSON в XML строку

type jsonDocument struct {
	content string
}

func (doc *jsonDocument) convertToXml() string {
	return fmt.Sprintf("<xml>%s</xml>", doc.content)
}

// --- 2. Целевой интерфейс (что ожидает клиент) ---
// AnaliticalService - интерфейс внешнего сервиса (потребителя)
// Мы не можем его менять, и он требует наличия метода sendXmlData
// xmlDocument - стандартный объект, который уже умеет работать с сервисом

type AnaliticalService interface {
	sendXmlData()
}

type xmlDocument struct{}

func (doc xmlDocument) sendXmlData() {
	fmt.Println("Отправка стандартного XML документа")
}

// --- 3. Адаптер ---
// jsonDocumentAdapter - мост между jsonDocument и интерфейсом AnaliticalService
// Он содержит внутри себя ссылку на адаптируемый объект (композиция)
// sendXmlData - реализация метода интерфейса AnaliticalService
// Адаптер получает вызов, подготавливает данные (конвертирует) и выполняет действие
// newJsonAdapter - это конструктор, который создает адаптер, возвращая интерфейс AnaliticalService
// За счет этого клиент може даже не знать, что он работает с адаптером

type jsonDocumentAdapter struct {
	jsonDocument *jsonDocument
}

func (adapter *jsonDocumentAdapter) sendXmlData() {
	// Делегируем работу внутреннему объекту
	xmlData := adapter.jsonDocument.convertToXml()
	fmt.Printf("Адаптер: данные преобразованы и отправлены: %s\n", xmlData)
}

func newJsonAdapter(doc *jsonDocument) AnaliticalService {
	return &jsonDocumentAdapter{
		jsonDocument: doc,
	}
}

// func main() {
// 	// Создаем наш JSON документ с какими-то данными
// 	myJson := &jsonDocument{content: "данные пользователя"}

// 	// Напрямую мы не можем передать myJson туда, где нужен AnaliticalService
// 	// Поэтому используем адаптер
// 	service := newJsonAdapter(myJson)

// 	// Теперь мы вызываем метод интерфейса
// 	// Клиент (main) думает, что просто отправляет данные в аналитику,
// 	// а адаптер внутри делает конвертацию
// 	fmt.Println("Клиент: Запускаю отправку данных...")
// 	service.sendXmlData()
// }

// # Паттерн проектирования: Адаптер (Adapter) на языке Go

// ## 1. Применимость (Когда использовать)
// Паттерн Адаптер используется, когда необходимо обеспечить совместную работу объектов с несовместимыми интерфейсами.

// *   **Интеграция сторонних библиотек:** Когда API библиотеки не совпадает с интерфейсом вашего приложения.
// *   **Legacy-код:** Использование старых компонентов в новой архитектуре без изменения их исходного кода.
// *   **Унификация API:** Когда нужно работать с несколькими поставщиками похожих услуг (например, разные облачные хранилища — AWS, Google Cloud), приводя их к единому стандарту в вашем коде.

// ---

// ## 2. Плюсы и минусы

// ### Плюсы (+)
// *   **Принцип открытости/закрытости (OCP):** Вы добавляете новые адаптеры, не меняя существующий код клиента.
// *   **Принцип единственной ответственности (SRP):** Логика конвертации данных вынесена в отдельный слой (адаптер).
// *   **Гибкость:** Позволяет менять реализацию "под капотом", не затрагивая основной бизнес-процесс.
// *   **Упрощение тестирования:** Позволяет легко подменять реальные объекты "заглушками" (моками) через интерфейс.

// ### Минусы (-)
// *   **Усложнение кода:** Требуется создание дополнительных структур и интерфейсов.
// *   **Оверхед:** В редких случаях (высоконагруженные системы) лишний слой вызовов может незначительно влиять на производительность.

// ---

// ## 3. Реальные примеры использования

// 1.  **Драйверы баз данных:** Пакет `database/sql` в Go использует адаптеры (драйверы) для взаимодействия с разными СУБД (PostgreSQL, MySQL, SQLite) через единый интерфейс.
// 2.  **Логирование:** Адаптация популярных библиотек (например, `uber-go/zap` или `sirupsen/logrus`) под внутренний интерфейс логгера вашей компании.
// 3.  **Платежные шлюзы:** Единый интерфейс для оплаты `Pay()`, который через разные адаптеры работает со Stripe, PayPal или криптовалютными кошельками.
// 4.  **Cloud Storage:** Адаптер, позволяющий коду работать с методом `Upload()`, независимо от того, куда летят данные — в AWS S3, Google Cloud Storage или локальное хранилище.

// ---

// ## 4. Как это работает в Go (Принцип)
// В Go паттерн реализуется через **композицию**:
// 1. Создается структура-адаптер.
// 2. В нее встраивается ссылка на адаптируемый объект.
// 3. Адаптер реализует методы нужного интерфейса, вызывая внутри себя методы встроенного объекта с необходимой трансформацией данных.
